# (PART) Data Visualisation {-}

# HTML widgets

In this chapter we cover the integration of JavaScript with R using the htmlwidgets package, which focuses on libraries that produce a visual output, it is often used for data visualisation but is not limited to it.

As in previous chapters we mainly learn by example, building multiple widgets of increasing complexity as we progress through the chapter. Before writing the first widget, we explore JavaScript libraries that make great candidates for htmlwidgets and attempt to understand how they work to grasp what is expected from the developer in order to integrate them with R. Finally, we build up on the previous chapter to improve how HTML widgets work with shiny.

## Candidate Libraries {-}

Before going down the rabbit hole it is good to take a look at the types of libraries one will work with. As htmlwidgets' main client are JavaScript visualisation libraries let us take a look at some such popular libraries and briefly look at how they work and what they have in common. This will greatly help conceptualise what one is trying to achieve in this chapter.

### Plotly {-}

[Plotly.js](https://plotly.com/javascript/) is probably one of the more popular out there, it provides over 40 fully customiseable chart types, many of which are very sophisticated. This is indeed the JavaScript library used by the R package of the same name: plotly.

Looking at the code presented in the "Get Started" guide reveals just how convenient the library is. One must import plotly, of course, then have a `<div>` where to visualisation will be placed, then, using `Plotly.newPlot`, create the actual visualisation by passing it first the element previously mentioned and a JSON of options.

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <!-- Import library -->
  <script src="plotly-latest.min.js"></script>
</head>

<body>
  <!-- div to hold visualisation -->
  <div id="chart" style="width:600px;height:250px;"></div>

  <!-- Script to create visualsiation -->
  <script>
    el = document.getElementById('chart');
    Plotly.newPlot(el, [{
      x: [1, 2, 3, 4, 5],
      y: [1, 2, 4, 8, 16] }]
    );
  </script>
</body>

</html>
```

Now let's look at how another popular library does it.

### Highchart.js {-}

[Highcharts](https://www.highcharts.com/) is another library which allows creating gorgeous visualisation, maps, and more, it's also very popular albeit not being entirely open-source.

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <!-- Import library -->
  <script src="highcharts.js"></script>
</head>

<body>
  <!-- div to hold visualisation -->
  <div id="chart" style="width:100%; height:400px;"></div>

  <!-- Script to create visualsiation -->
  <script>
    var myChart = Highcharts.chart('chart', {
        xAxis: {
            categories: ['Apples', 'Bananas', 'Oranges']
        },
        series: [{
            name: 'Jane',
            data: [1, 0, 4]
        }, {
            name: 'John',
            data: [5, 7, 3]
        }]
    });
  </script>
</body>

</html>
```

The above is very similar to what plotly.js requires: import libraries, create a `<div>` where to put the visualisation, and, to create the chart, run a function which also takes the id of the div where to place the chart and a JSON of options defining the actual chart, including the data.

### Chart.js {-}

[Chart.js](https://www.chartjs.org/) is yet another library which to draw standard charts popular for its permissive license and convenient API.

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <!-- Import library -->
  <script src="Chart.min.js"></script>
</head>

<body>
  <!-- canvas to hold visualisation -->
  <canvas id="chart" width="400" height="400"></canvas>

  <!-- Script to create visualsiation -->
  <script>
    var el = document.getElementById('chart').getContext('2d');    
    var myChart = new Chart(el, {
      type: 'bar',
      data: {
        labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],
        datasets: [{
          label: '# of Votes',
          data: [12, 19, 3, 5, 2, 3]
        }]
      }
    });
  </script>
</body>

</html>
```

We again observe a very similar structure as with previous libraries. The library is imported, instead of a `div` chart.js uses a `canvas`, and the visualisation is also created from a single function which takes the canvas as first argument and a JSON of options as second.

Hopefully this reveals the repeating structure such libraries tend to follow and also hints at should be reproduced, to some extent at least, using R.

## How it works {-}

Imagine there is no such package as HTML widgets to help create interactive visualisations from R: how would one attempt to go about it?

An interactive visualisation using JavaScript will will be contained within an HTML document, therefore it would probably have to be created first. Secondly, the visualisation that is yet to be created likely relies on external libraries, these would need to be imported in the document. The document should also include an HTML element (e.g.: `<div>`) to host said visualisation. Then data would have to be serialised in R and embedded into the document where it should be read by JavaScript code that uses it to create the visualisation. Finally all should be managed to work seamlessly across R markdown, shiny, and other settings.

Thankfully the htmlwidgets package is there to handle most of this. Nonetheless, it is important to understand that these operations are undertaken (to some degree) by htmlwidgets as it greatly helps use the package.

Must remember when building HTML widgets:

- Import dependencies
- Create an html element to hold visualisation
- Serialise R data to JSON
- Handle JSON data to produce visualisation

## The Scaffold {-}

With some vague understanding of how such widgets work internally one is ready to "scaffold" one with the aim of rummaging through its components to grasp a greater understanding of how such interactive outputs are actually produced. The way one sets up such a package is stunningly simple. Below we create a package named "playground" which will be used to mess around and explore. Though one could probably create widgets outside of an R package, it would only make things more complicated.

```r
create_package("playground")
```

Then, from the root of the package created, we scaffold a widget which we call "play".

```r
htmlwidgets::scaffoldWidget("play")
```

This function puts together the minimalistic structure necessary to implement an HTML widget and opens `play.R`, `play.js` and `play.yaml` in the RStudio IDE or the default text editor. These files are named after the widget and will form the core of our package. The R file contains core functions of the R API, namely the `play` function which creates the widget itself, and the `render*` and `*output` functions that handle the widget in the shiny server and UI respectively. The `.js` file contains JavaScript functions that actually generate the visual output. 

```r
devtools::document()
devtools::load_all()
```

It might be hard to believe, but at this stage one already has a fully functioning widget ready to use after documenting, and building the package. Indeed, the `play.R` file that that was created contains a function named "play" ẁhich takes, amongst other arguments, a message.  

```r
play(message = "This is a widget!")
```

![First HTML widget](images/playground-1.png)

This displays the message in the RStudio "Viewer," or the your default browser which indicates that the function does indeed create an HTML output. One can use the the ![](images/open-in-browser.png) button located in the top right of the RStudio "Viewer" to open the message in web browser which can prove very useful to look under the hood of the widgets for debugging.

## The Output {-}

With an out-of-the-box HTML widget package one can start exploring the internals to understand how it works. Let's start by retracing the path taken by the message written in R to its seemingly magical appearance in HTML. The `play` function previously used, takes the `message` wraps it into a list which is then used in `htmlwidgets::createWidget`.

```r
# forward options using x
x = list(
  message = message
)
```

Wrapping a string in a list might seem unnecessary but one will eventually add variables when building a more complex widget, starting with a list makes it easier to add them later on. 

To investigate the widget we should look under the hood; the source code of the created (and rendered) output can be accessed in different ways, 1) by right-clicking on the message displayed in the RStudio Viewer and selecting "Inspect element," or 2) by opening the visualisation in your browser using the ![](images/open-in-browser.png) button located in the top right of the "Viewer," and in the browser right clicking on the message to select "Inspect." The latter is advised as web browsers such as Chrome or Firefox provide much friendlier interfaces for such functionalities as well as shortcuts to inspect or view the source code of a page.

Below is a part of the `<body>` of the output of `play("This is a widget!")` obtained with the method described in the previous paragraph.

```html
<div id="htmlwidget_container">
  <div id="htmlwidget-c21cca0e76e520b46fc7" style="width:960px;height:500px;" class="play html-widget">This is a widget!</div>
</div>
<script type="application/json" data-for="htmlwidget-c21cca0e76e520b46fc7">{"x":{"message":"This is a widget!"},"evals":[],"jsHooks":[]}</script>
```

One thing the source code of the rendered output reveals is the element (`div`) created by the htmlwidgets package to hold the message (it has the class name of our widget, `play`), as well as, below it, in the `<script>` tag, the JSON object which includes the `x` variable used in the `play` function. The `div` created bears a randomly generated `id` which one can define when creating the widget using the `elementId` argument.

```r
# specify the id
play("This is another widget", elementId = "myViz")
```

```html
<!-- div bears id specified in R -->
<div id="myViz" style="width:960px;height:500px;" class="play html-widget">This is another widget</div>
```

You will also notice that this affects the `script` tag below it, the `data-for` attribute of which is also set to "myViz," this indicates that it is used to tie the JSON data to a `div`, essential for htmlwidgets to manage multiple visualisation in R markdown or Shiny for instance. Then again, this happens in the background without the developer (you) having to worry about it.

```html
<script type="application/json" data-for="myViz">{"x":{"message":"This is a widget!"},"evals":[],"jsHooks":[]}</script>
```

Inspecting the output also shows the dependencies imported, these are placed within the `head` HTML tags at the top of the page. 

```html
<script src="lib/htmlwidgets-1.5.1/htmlwidgets.js"></script>
<script src="lib/play-binding-0.0.0.9000/play.js"></script>
```

This effectively imports the `htmlwidgets.js` library as well as the `play.js` file, and were the visualisation depending on external libraries they would appear alongside those. Peaking inside the `play.js` file located at `inst/htmlwidgets/play.js` reveals the code below we see:

```js
// play.js
HTMLWidgets.widget({

  name: 'play',

  type: 'output',

  factory: function(el, width, height) {

    // TODO: define shared variables for this instance

    return {

      renderValue: function(x) {

        // TODO: code to render the widget, e.g.
        el.innerText = x.message;

      },

      resize: function(width, height) {

        // TODO: code to re-render the widget with a new size

      }

    };
  }
});
```

However convoluted this may appear at first do not let that intimate you. The `factory` function returns two functions, one of which, `resize`, is currently empty, let's therefore look at the other one first, `renderValue`: the function that in fact renders the visualisation. It takes an object `x` from which is accesses the "message" variable that it uses as text for object `el` (`el.innerText`). The object `x` passed to this function is actually the list of the same name that was build in the R function `play`! While in R one would access the `message` in list `x` with `x$message` in JavaScript to access the `message` in the JSON `x` one writes `x.message`, only changing the dollar sign to a dot. Let's show this perhaps more clearly by printing the content of `x`.

```js
console.log(x);
el.innerText = x.message;
```

We place `console.log` to print the content of `x` in the console, reload the package with `devtools::load_all` and use the function `play` again then explore the console from the browser (inspect and go to the "console" tab).

![Console tab output](images/playground-console-x.png)

This displays the JSON object containing the message: it looks eerily similar to the list that was created in R (`x = list(message = "This is a widget!")`). What one should take away from this is that data that needs to be communicated from R to the JavaScript function should be placed in the R list `x`. This list is serialised to JSON and placed in the HTML output in a `script` tag with a `data-for` attribute. This attribute indicates which widget the data is destined for. This effectively enables htmlwidgets to match the serialised data with the output elements: data in `<script data-for='viz'>` is to be used to create a visualisation in `<div id='viz'>`.

Before we move on to other things one should also grasp a better understanding of the `el` object, which can also be logged in the console.

```js
console.log(x);
console.log(el);
el.innerText = x.message;
```

![Console tab output](images/playground-console-el.png)

This displays the HTML element created by htmlwidgets that is meant to hold the visualisation, or in this case, the message. If you are familiar with JavaScript, this is the element that would be returned by `document.getElementById`. This object allows manipulating the element in pretty much any way imaginable, change its position, its colour, its size, or, as done here, to insert some text in its place. What's more one can access attributes of the object just like a JSON array. Therefore one can log the `id` of the element.

```js
// print the id of the element
console.log(el.id);
el.innerText = x.message;
```

Making the modifications above and reloading the package, one can create a widget given a specific id and see it displayed in the console, e.g.: `play("hello", elementId = "see-you-in-the-console")`.

In an attempt to become more at ease with this setup let us change something and play with the widget. Out-of-the-box htmlwidgets uses `innerText`, which does very much what it says on the tin, it places text inside an element. JavaScript comes with another function akin to `innerText`, `innerHTML`. While the former only allows inserting text the former lets one insert any HTML.

```js
el.innerHTML = x.message;
```

After changing the `play.js` file as above, and re-loading the package, one can use arbitrary HTML as messages.

```r
play("<h1>Using HTML!</h1>")
```

![Widget output](images/playground-h1.png)

That makes for a great improvement which opens the door to many possibilities. However, the interface this provides is unintuitive. Albeit similar, R users are more familiar with shiny and htmltools [@R-htmltools] tags than HTML tags, e.g.: `<h1></h1>` translates to `h1()` in R. The package should allow users to use those instead of forcing them to collapse HTML content in a string. Fortunately, there is a very easy way to obtain the HTML from those functions: convert it to a character string.

```{r}
html <- shiny::h1("HTML tag")

class(html)

# returns string
as.character(html)
```

Implementing this in the `play` function will look like this.

```r
# forward options using x
x = list(
  message = as.character(message)
)
```

Reloading the package with `devtools::load_all` lets one use shiny tags as the message.

```r
play(shiny::h2("Chocolate is a colour", style = "color:chocolate;"))
```

![Using shiny tags](images/playground-color.png)

This hopefully provides some understanding of how htmlwidgets work internally and thereby helps building such packages. To recapitulate, an HTML document is created in which div is placed and given a certain id, this id is also used in a script tag that contains JSON data passed from R so that a JavaScript function we define can read that data in and use it to generate a visual output in a div. However, as much as this section covered, the topic of JavaScript dependencies was not touched, this is approached in the following section where we build another, more interesting widget, which uses an external dependency.

## Typed.js {-}

In this section we build a package called `typed`, which wraps the JavaScript library of the same name, [typed.js](https://github.com/mattboldt/typed.js/) that mimics text being typed. This builds upon many things we explored in the playground package.

```r
usethis::create_package("typed")
htmlwidgets::scaffoldWidget("typed")
```

As done with candidate libraries, let's take a look at documentation of [typed.js](https://github.com/mattboldt/typed.js/) to see how typed.js works.

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <!-- Import library -->
  <script src="typed.js"></script>
</head>

<body>
  <!-- div to hold visualisation -->
  <div class="element"></div>

  <!-- Script to create visualsiation -->
  <script>
    var typed = new Typed('.element', {
      strings: ['First sentence.', 'And a second sentence.']
    });
  </script>
</body>

</html>
```

The code above is not very different from what was observed in other libraries: the library is imported, there is a `<div>` where the output will be generated, and a script which also takes a selector and a JSON of options.

### Dependency {-}

Once the package created and the widget scaffold laid down we need to add the JavaScript dependency without which nothing can move forward. The [documentation in the README of typed.js](https://github.com/mattboldt/typed.js) states that it can be imported like so.

```html
<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"></script>
```

First, we will download the dependency, which consists of a single JavaScript file, instead of using the CDN as this ultimately makes the package more robust (more easily reproducible outputs and no requirement for internet connection). Below we place the dependency in a "typed" directory within the "htmlwidgets" folder.

```r
dir.create("./inst/htmlwidgets/typed")
cdn <- "https://cdn.jsdelivr.net/npm/typed.js@2.0.11"
download.file(cdn, "./inst/htmlwidgets/typed/typed.min.js")
```

This produces a directory that looks like this:

```
.
├── DESCRIPTION
├── NAMESPACE
├── R
│   └── typed.R
└── inst
    └── htmlwidgets
        ├── typed
        │   └── typed.min.js
        ├── typed.js
        └── typed.yaml
```

In htmlwidgets packages dependencies are specified in the `.yml` file located at `inst/htmlwidgets` which at first contains a commented template.

```yml
# (uncomment to add a dependency)
# dependencies:
#  - name:
#    version:
#    src:
#    script:
#    stylesheet:
```

Let's uncomment those lines as instructed at the top of the file and fill it in.

```yml
dependencies:
  - name: typed.js
    version: 2.0.11
    src: htmlwidgets/typed
    script: typed.min.js
```

We remove the `stylesheet` entry as this package does not require any CSS files. The `src` specifies the path to the directory containing the scripts and stylesheets. This is akin to using the `system.file` function to return the full path to a file or directory within the package.

```r
devtools::load_all()
system.file("htmlwidgets/typed", package = "typed")                                         
#> "/home/me/packages/typed/inst/htmlwidgets/typed"
```

We should verify that this is correct by using the one R function the package features and check the source code of the output to verify that the typed.js is indeed imported. We thus run `typed("test")`, open the output in the browser (![](images/open-in-browser.png)) and look at the source code of the page (right click and select "View page source"). At the top of the page one should see `typed.min.js` imported, click the link to ensure it correctly points to the dependency.

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>body{background-color:white;}</style>
<script src="lib/htmlwidgets-1.5.1/htmlwidgets.js"></script>
<script src="lib/typed.js-2.0.11/typed.min.js"></script>
<script src="lib/typed-binding-0.0.0.9000/typed.js"></script>
...
```

### JavaScript {-}

On its [official website](https://mattboldt.com/demos/typed-js/), typed.js gives the following example. The JavaScript function `Typed` takes two arguments, first the selector, the element to hold the output, second a JSON of options to specify what is being typed and a myriad of other things. 

```js
var typed = new Typed('.element', {
  strings: ["First sentence.", "Second sentence."],
  typeSpeed: 30
});
```

Let's place it in our package by replacing the content of the `renderValue` in `typed.js` with the above.

```js
...
renderValue: function(x) {

  var typed = new Typed('.element', {
    strings: ["First sentence.", "Second sentence."],
    typeSpeed: 30
  });

}
...
```

One could be tempted to run `devtools::load_all` but this will not work, namely because the function uses a selector that is will not return any object; it needs to be applied to the div created by the widget not `.element`. As hinted at in the playground, the selector of the element created is accessible from the `el` object. As a matter of fact, we did log in the browser console the id of the created div taken from `el.id`. Therefore concatenating the pound sign and the element id produces the select to said element. (`.class`, `#id`)

```js
// typed.js
...
renderValue: function(x) {

  var typed = new Typed('#' + el.id, {
    strings: ["First sentence.", "Second sentence."],
    typeSpeed: 30
  });

}
...
```

This should now work, run `devtools::load_all` followed by `typed("whatever")` and the JavaScript animated text will appear! It's not of any use just yet as the options, included the text being typed is predefined: the package is currently not making any use the of the inputs passed from R. Below change the default strings to `x.message`.

```js
// typed.js
...
renderValue: function(x) {

  var typed = new Typed('#' + el.id, {
    strings: x.message,
    typeSpeed: 30
  });

}
...
```

This, however, will cause issues as the `strings` options expects and array (vector) and not a single string. This is something often forgotten when working with R, there is no scalar values, in R a scalar is vector of length 1.

```r
typed("does not work") # length =  1
typed(c("This", "will", "work")) # length > 1
```

One solution is to force the input into a list.

```r
# typed.R
x = list(
  message = as.list(message)
)
```

At this juncture the package works but there is a salient issue with the way it handles options. Why build a list in R to reconstruct it in JavaScript manually. Since the options are serialised in R to JSON and that typed.js expects a JSON of options it is actually cleaner and more convenient to construct an R list that mirrors the JSON array so one can use is as-is in JavaScript.

In fact, renaming the `message` to `strings` effectively does this.

```r
# typed.R
x = list(
  strings = as.list(message)
)
```

This allows greatly simplifying the code JavaScript side, making it much easier to add other options down the line, maintain, debug, and read.

```js
// typed.js
...
renderValue: function(x) {

  var typed = new Typed('#' + el.id, x);

}
...
```

One can now add more options from the R code without having to alter any of the JavaScript. Let us demonstrate with the `loop` option.

```r
typed <- function(message, loop = FALSE, width = NULL, height = NULL, elementId = NULL) {

  # forward options using x
  x = list(
    loop = loop,
    strings = as.list(message)
  )

  # create widget
  htmlwidgets::createWidget(
    name = 'typed',
    x,
    width = width,
    height = height,
    package = 'typed',
    elementId = elementId
  )
}
```

### HTML Element {-}

As pointed out multiple times, the widget is generated in a `<div>`, which is works fine for most visualisation libraries. But we saw that chart.js requires placing it in a `<canvas>`, so one needs the ability to change that. It could be interesting to apply this to typed.js too as within a `<div>` it cannot be placed inline, using a `<span>`, however, this would work.

This can be changed by placing a function named `nameOfWidget_html` which looked up by htmlwidgets and used if found. This function takes the three-dot construct `...` and uses them in an htmltools tag. The three-dots are necessary because internally htmlwidgets needs be able to pass arguments, such as the all too critical `id`.

```r
typed_html <- function(...){
  htmltools::tags$span(...)
}
```

### Exercises {-}

The full list of which is available in the [documentation of typed.js](https://github.com/mattboldt/typed.js/#customization). There are multiple ways to complete this package with regard to the options that are made available R-side and the API one wants to provide users of the package.

1. Keep adding arguments as done with `loop`
2. Use the three-dot construct (`...`) instead of adding arguments individually.
3. Provide other functions for additional options.

It might be unclear how to implement the last point, this is something we'll explore in the following section.

## Second Widget - Gio.js {-}

With a first widget built one can jump onto another one: [gio.js](https://giojs.org/), a library to draw arcs between countries on a 3 dimensional globe. This will include many more functionalities such packages can comprise.

![Example of Gio.js visualisation](images/gio-example.png)
